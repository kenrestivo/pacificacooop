<!-- $Id$ -->
<?php

#	functions specific to auth

#  Copyright (C) 2003  ken restivo <ken@restivo.org>
#
#  some stuff lifted from
#  POST-NUKE Content Management System
#  Copyright (C) 2001 by the Post-Nuke Development Team.
#  http://www.postnuke.com/
#  ----------------------------------------------------------------------
#  Based on:
#  PHP-NUKE Web Portal System - http://phpnuke.org/
#  Thatware - http://thatware.org/
# 
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
# 
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details. 
# 
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


require_once("movetoshared.inc");

define('MIN_PASS', 5);

#thank you, phpnuke
define('ACCESS_INVALID', -1);
define('ACCESS_NONE', 0);
define('ACCESS_SUMMARY', 100);
define('ACCESS_VIEW', 200);
define('ACCESS_EDIT', 500);
define('ACCESS_ADD', 600);
define('ACCESS_DELETE', 700);
define('ACCESS_ADMIN', 800);

$accessnames = array(  
		  0 => 'None',
		100 => 'See totals',
		200 => 'View details',
		500 => 'Edit',
		600 => 'Add',
		700 => 'Delete',
		800 => 'Administer permissions'
);



/******************
	SAVEPASS
	commits this user's new/changed password to the database
	inputs: uid, password in clear text
	returns: a token, generated by call to generateToken()
******************/
function 
savePass($uid, $clearpass)
{
	// be paranoid
	if(!($uid && $clearpass)){
		user_error("savePass(): ERROR! need to pass in a uid AND a password\n", E_USER_ERROR);
		exit(1);
	}

	$hash = strtolower(md5($clearpass));

	$query = sprintf("update users set password = '%s' where userid = %d ",
				$hash, $uid);
	mysql_query($query);
	$err = mysql_error();
	if($err){
		//TODO: log this, don't display it
		user_error("savePass(): [SECRET]: $err", E_USER_ERROR);
		return 0;
	}

	//user_error("saving $uid, $hash, [$query]", o);
	return generateToken($uid, $hash);

} /* END SAVEPASS */
					


/******************
	GETPASS
	get the password hash stored for this user, 
	inputs: uid
	returns: the hash if OK, 0 if no password, or -1 if no user!
******************/
function 
getPass($uid)
{
	// sanitny check
	if($uid < 1){
		user_error("getPass(): ERROR! $uid < 1",E_USER_ERROR);
		exit(1);
	}

	// the query
	$query = sprintf("SELECT * FROM users WHERE userid = %d ", $uid);
	//user_error("getPass(): [$query]", E_USER_NOTICE);
	$listq = mysql_query($query);
	$err = mysql_error();
	if($err){
		#TODO: log this, don't display it
		user_error("getPass(): [SECRET]: $err\n", E_USER_ERROR);
	}
				
	if (mysql_num_rows($listq) > 0) {
	}                  

	while($row = mysql_fetch_assoc($listq)){
		//grab 'em all XXX is this really necessary?
		//user_error(sprintf("debug %s\n", $row['name']), E_USER_NOTICE);
		if($row['password']){
			//user_error("getPass(): got one for $uid", E_USER_NOTICE);
			return($row['password']); //success!
		} else {
			user_error("getPass(): no password for uid $uid",E_USER_NOTICE);
			return 0; // no password entered yet for this uid
		}
	}


	user_error("getPass(): no password for $uid", E_USER_NOTICE);
	return 0;
} /* END GETPASS */


/******************
	GENERATETOKEN
	inputs: uid, the hashed password from the db
	returns: a token (md5 hash of hashed passwd in db, and uid
******************/
function
generateToken($uid, $passhash)
{	
	if(!($uid && $passhash)){
		user_error("generateToken(): ERROR! need to pass in a uid AND a hash\n", 			E_USER_ERROR);
		exit(1);
	}
	//ok, the hash
	return strtolower(md5($uid . strtolower($passhash)));
			
}/* END GENEREATETOKEN */


/******************
	CHECKTOKEN
	check that the token is valid for this uid
	inputs: uid, token
	returns: 0 if ok, 1 if failure
******************/
function
checkToken($uid, $token)
{
	if(!($uid && $token)){
		return 1; // MUST supply both.
	}

	$storedpass = getPass($uid);
	if(!$storedpass){
		return 1; // no such user
	}

	// seemple
	if($token == generateToken($uid, $storedpass)){
		return 0;
	}	
	
	return 1;
}/* END CHECKTOKEN */


/******************
	CHECKPASS
	check that the cleartext password matches the md5 hash in the db
	inputs: uid, token
	returns: token if ok, 0 if failure
******************/
function
checkPass($uid, $clearpass)
{
	if(!($uid && $clearpass)){
		return 0; // MUST supply both.
	}

	$storedpass = getPass($uid);
	if(!$storedpass){
		return 0; // no such user
	}

	// passwords are stored as HASHES in database, remember?
	$md5pass = strtolower(md5($clearpass));
	//user_error("checkPass($uid, $clearpass) produces md5 of $md5pass", E_USER_NOTICE);

	if($storedpass == $md5pass){
		return generateToken($uid, $md5pass);
	}	
	
	return 0;
}/* END CHECKPASS */



/******************
	QUICKLEVELCHECK
	inputs: targetlevel, targetfamilyid, perms struct(from getAuthLevel), 
		userstruct (from getUser)
	return 0 if ok, 1 if no good
******************/
function
quickLevelCheck($targetlevel, $targetfamilyid, $permstruct, $userstruct)
{
		if(($permstruct['userlevel'] >= $targetlevel  && 
			$targetfamilyid == $userstruct['familyid']) || 
			$permstruct['grouplevel'] >= $targetlevel) 
		{
			return 0;
		}

	return 1;
}/* END QUICKLEVELCHECK */



/******************
	CHEKAUTHLEVEL
	the highest-level function for checking authorisation
		yes/no = A(auth, family to compare to, realm, level i need, [group i need])
			check the familyid match, the level in the db, and return whatever
	inputs: auth, family to compare to, realm, level i need, [later, group ]
	returns: 0 if ok, 1 if error
******************/
function
checkAuthLevel($auth, $targetfamilyid, $targetrealm, $targetlevel)
{
	$level = aggregateLevel($auth, $targetfamilyid, $targetrealm);

	return $targetlevel >= $level ? 0 : 1;
}/* END CHEKAUTHLEVEL */




/******************
	AGGREGATELEVEL
	return the maximum level i can get with this combination of  args
			check the familyid match, the level in the db, and return highest avail
				i.e. if my families don't match, return group level, otherwise userlevel
	inputs: auth, family to compare to, realm [later group], 
	returns: max level for this action
******************/
function
aggregateLevel($auth, $targetfamilyid, $targetrealm)
{
	$perms = getAuthLevel($auth, $targetrealm);
	$u = getUser($auth['uid']);
	if(!$perms || !$u){
		return 0; //pass through the nothing.
	}

	//userlevel is only relevent if i'm that family. duh
	if($targetfamilyid == $u['familyid'] ){
		$userlevel = $perms['userlevel'] ;
	}
	
	//i want to know the higher of the two.
	return $userlevel > $perms['grouplevel'] ? $userlevel : $perms['grouplevel'];
	
}/* END AGGREGATELEVEL */


/******************
	GETAUTHLEVEL
		return what's up for this uid, let caller decide if that's good or bad
		checks token just so stuff doesn't sneak up on us
	inputs: auth structure,realm, and eventually group
	returns: array of userlevel and grouplevel, or null if checktoken fails
******************/
function
getAuthLevel($auth, $targetrealm)
{

	//confessArray($auth, "getauthlevel");

	if(!($auth['uid'] && $targetrealm && $auth['token'] )) {
		user_error("getAuthLevel(): ERROR not enough info",E_USER_ERROR);
		return 1;
	}

	if(checkToken($auth['uid'], $auth['token'])){
		//user_error("getAuthLevel(): bad TOKEN", E_USER_WARNING);
		return 0; // bad token, no BISCUIT!
	}

	// the query
	$query = sprintf("
			SELECT privs.*
				FROM privs
			WHERE privs.userid = %d 
				and (privs.realm = '%s' or privs.realm = 'all')
			",
			$auth['uid'], $targetrealm
		);
	//user_error("getAuthLevel(): [$query]: ", E_USER_NOTICE);
	$listq = mysql_query($query);
	$err = mysql_error();
	if($err){
		user_error("getAuthLevel(): [$query]: $err", E_USER_ERROR);
	}
				
	if (mysql_num_rows($listq) != 1){
		user_error(sprintf("getAuthLevel(): You may NOT have more than one entry for userid %d and realm %d (and later, group)! The database is corrupted!", $auth['uid'], $realm), 
			E_USER_ERROR);
		return 0; // there can beeee... only one!
	}                  

	while($row = mysql_fetch_assoc($listq)){
		$result['userlevel'] = $row['userlevel'];
		$result['grouplevel'] = $row['grouplevel'];
	}

	return $result;
}/* END GETAUTHLEVEL */



/******************
	GETUSER
	inputs: uid
	returns: returns the human name of who they are logged in, 
			and the familyid and familyname if there is one
		or 0 if none!
******************/
function
getUser($uid)
{

	if($uid < 1){
		user_error("ERROR! no uid", E_USER_ERROR);
		exit(1);
	}

	// the query
	$query = sprintf("
		SELECT users.name as username, families.name as familyname, 
				users.familyid
			FROM users 
			left join families on families.familyid = users.familyid
			WHERE users.userid = %d ",
				$uid );
	$listq = mysql_query($query);
	$err = mysql_error();
	if($err){
		user_error("getUser(): [$query]: $err", E_USER_ERROR);
	}
				
	// sanity czech
	if (mysql_num_rows($listq) < 1) {
		user_error(
			"getUser(): ERROR [$query]! no name for family with uid $uid?", 
				E_USER_WARNING);
		return 0;
	}

	while($row = mysql_fetch_assoc($listq)){
		$savedrow = array_reverse($row); //XXX hack around mysql
	}

	return $savedrow;

}/* END GETUSER */



/******************
	SHOWACCESSLEVELS
	prints out a description of user permissions for this realm
	inputs: perms struct, and a realm name
	outputs: text showing what the user's perms are
******************/
function
showAccessLevels($p, $pfield, $realm)
{
	global $accessnames;
	$i = 0;
	while (list($key, $val) = each($accessnames)){
		//print "[$key] ";
		if($key <= $p[$pfield] && $key > 0){
			printf("%s%s",  $i ? ", " : "", $accessnames[$key]);
			$i++;
		}
	}
	reset ($accessnames);
}/* END SHOWACCESSLEVELS */



/******************
	LOGINPOPUP
	drawing the popup
		query all users. doy.
		if an id is passed in, use that one as default. 
		otherwise, CHOOSE ONE
	inputs: uid
	outputs: renders the popup
******************/
function loginPopup($uid)
{
	print "<select name='auth[uid]' SINGLE>\n";
	print "<option value='0'>CHOOSE ONE</option>\n";

	#DO THE QUERY
	$listq = mysql_query(" select * from users order by name");
	$err = mysql_error();
	if($err){
		user_error("loginPopup(): [$listq]: $err",E_USER_ERROR);
	}
	while($row = mysql_fetch_array($listq)){
		$sel = $row['userid'] == $uid ? " selected" : "";
		printf("<option value='%d' %s>%s</option>\n", 
			$row['userid'], $sel, $row['name']);
 
	}
	print "\n</select>";
}/* END LOGINPOPUP */
	

/******************
	LOGOUTFORM
	inputs: auth struct, type(password, confirm, both), and user(show, hide)
	outputs: a nice login entry form.
	TODO clean this up if possible. it's ugly. but then, hey, it's html!
******************/
function
logoutForm()
{

	printf("<FORM METHOD=POST ACTION='%s'>", 
					"index.php"); //force it to go back to index
	printf("<INPUT TYPE=submit NAME='logout' VALUE='Log Out'>");
    print "</FORM>";
}/* END LOGOUTFORM */

/******************
	LOGINFORM
	inputs: auth struct, type(password, confirm, both), and user(show, hide)
	outputs: a nice login entry form.
	TODO clean this up if possible. it's ugly. but then, hey, it's html!
******************/
function
loginForm($auth, $type = 'password', $user = 'show', $statusline)
{

	// say hi.
	print "<p>$statusline</p>";

	printf("<FORM METHOD=POST ACTION='%s'>", 
					$_SERVER['PHP_SELF']);
	if($auth){ //hey, it could happen...
		thruAuth($auth);
	}
	print "<table border=1>";
	//user popup (or display) stuff
	print "<tr>";
	if($user == 'show'){
		print "<td>Select user name:</td>\n";
		print "<td>";
		loginPopup($auth['uid']);
		print "</td>";
	} else {
		$u = getUser($auth['uid']);
		printf("<td>Logging in %s...</td>\n", $u['username']);
	}
	print "</tr>";

	//password stuff
	print "<tr>";
	if($type == 'password' || $type == 'both'){
		if($type == 'both'){ //XXX hack. i can't pass the REAL state thru.
			print "<td>Please type in your new password here: </td>\n";
		} else {
			print "<td>Enter password 
				(or leave blank if you don't have one yet): </td>\n";
		}
		print "<td><INPUT TYPE=password NAME='auth[pwd]'></td>";
	}
	print "</tr>";

	//confirm stuff
	print "<tr>";
	if($type == 'confirm' || $type == 'both'){
		print "<td>Please re-type your password to confirm it: </td>\n";
		print "<td><INPUT TYPE=password NAME='auth[confirm]'></td>";
	}
	print "</tr>";

	print "</table>";

	printf("<INPUT TYPE=submit NAME='login' VALUE='%s'>",
		$type == 'confirm' || $type == 'both' ? 'Save New Password' : 'Log In');
	printf("<INPUT TYPE=submit NAME='logout' VALUE='Cancel'>");
    print "</FORM>";
}/* END LOGINFORM */


/******************
	LOGIN
	the state machine
		only returns if it either needs more user input or is finished!
		if it returns without state == 'loggedin', caller wants to done()
	inputs: HTTP_VARS
	outputs: status/error messages as needed
	returns: the auth struct with necessary changes
******************/
function
logIn($vars)
{
	//confessArray($vars, 'logIn($auth) called with');

	//force us to drop all previous state if 'cancel' button pressed!
	$auth = $vars['logout'] ? "" : $vars['auth'];


	/* vital information for each state.
		func = callback function for this state
		required = mandatory elements of the auth structure for this state
		wanted = optional elements of the auth structure for this state
		terminus = if we reach this state, exit the state machine
		description = some debug/explanatory text. not used right now
	*/
	$states = array(
		unknown => array (
					func => "unknownState",
					description => "Indeterminate state."
					),
		needlogin => array (
					func => "needLoginState",
					wanted => array ( "uid"),
					description => "You must log in, but you haven't yet"
					),
		loggedout => array (
					func => "loggedOutState",
					wanted => array ( "uid"),
					description => "Forcibly and deliberately logged out"
					),
		nullpass => array (
					func => "nullPassState",
					required => array ( "uid"),
					wanted => array ( "pwd", "confirm"),
					description => "User has no password in database"
					),
		checklogin => array (
					func => "checkLoginState",
					required => array ("uid", "pwd"),
					description => "Checking password"
					),
		verifytoken => array (
					func => "verifyTokenState",
					required => array ( "uid", "token"),
					description => "Checking token"
					),
		wrongpass => array (
					func => "wrongPassState",
					required => array ( "uid"),
					description => "Wrong password"
					),
		nouser => array (
					func => "noUserState",
					required => array ( "uid"),
					description => "No such user"
					),
		needconfirm => array (
					func => "needConfirmState",
					required => array ( "uid", "pwd"),
					description => "Need new password confirmed"
					),
		confirmwrong => array (
					func => "confirmWrongState",
					required => array ( "uid"),
					description => "Confirmation password doesn't match"
					),
		insecurepass => array (
					func => "insecurePassState",
					required => array ( "uid", "pwd"),
					description => "New password doesn't meet minimums"
					),
		loggedin => array (
					terminus => "yes",
					func => "loggedInState",
					required => array ( "uid", "token"),
					description => "User is logged in"
					),
		needinput => array (
					terminus => "yes",
					description => "UI needs input. Exit state machine."
					)
	);

	// deal with nothing passed in
	if(!$auth['state']){
		$auth['state'] == 'unknown';
	}
	if(!$auth){
		$auth = array( state => 'unknown' );
	}

	
	/* start the pachinko machine. 
		no way out unless user input needed, or success */

	do{

		// are all our required inputs present?
		$auth = sanityCheck($auth, $states);

		$state = $auth['state']; // easier on the eyes!

		user_error("logIn(): in $state", E_USER_NOTICE);

		/* confessArray($auth, sprintf("login() calling %s() with", 
				$states[$state]['func'] )); 
		*/

		// dispatch the appropriate action for this state, and collect result
		$func = $states[$state]['func'];
		if($func){
			// we want the func. gotta have the func. yowwww...
			$auth = $func($auth, $states);
		}
	} while(!$states[$state]['terminus']);


	return($auth);

}/* END LOGIN  */


/******************
	SANITYCHECK
	make sure a state has the minimum inputs required for it
	inputs: an auth struct, and a states struct to compare it to
	returns: the auth struct, with new state if needed
******************/
function
sanityCheck($auth, $states)
{
	$state = $auth['state'];
	if(!$states[$state]){
			user_error("sanityCheck(): $state is an illegal state. Forcing unknown state", 
				E_USER_WARNING);
			// NOTE! i do NOT use changeState() here
			$auth['state'] = 'unknown'; // force it outta here
	}
	if ($states[$state]['required']){
		while (list($key, $val) = each($states[$state]['required'])){
			if(!$auth[$val]){
				//serious. potential security violation.
				user_error("sanityCheck(): $val required for state $state. Forcing 'unknown' state.", E_USER_WARNING);
				$auth['state'] = 'unknown'; // force it outta here
			}
		}
		reset($auth);
	}


	//check that uid is valid, if supplied
	if($auth['uid'] && !getUser($auth['uid'])){
		user_error(
			sprintf("unknownState(): uid %d present, but user not in db", 
				$auth['uid'])
		, E_USER_NOTICE);
		$auth['state'] = 'nouser'; // force it outta here
	}

	return $auth;
}/* END SANITYCHECK */


/******************
	CHANGESTATE
	utility function, kind of like a copy/constructor method
	makes a copy of an auth struct passed in, copying required fields in
		or, optionally, the wanted fields too
		and changes its state to the one passed in
	inputs: auth struct, states struct, new state, and 'wanted' flag
	returns: a copy of the struct with changes as above
******************/
function
changeState($auth, $states, $newstate, $wanted)
{
	$newauth = array( state => $newstate );

	if($states[$newstate]['required']){
		while (list($key, $val) = each($states[$newstate]['required'])){
			if($auth[$val]){
				$newauth[$val] = $auth[$val];
			}
		}
	}

	if($wanted && $states[$newstate]['wanted']){
		while (list($key, $val) = each($states[$newstate]['wanted'])){
			if($auth[$val]){
				$newauth[$val] = $auth[$val];
			}
		}
	}

	//clean up the mess we made
	reset($auth);
	reset($states);

	return $newauth;
		
}/* END CHANGESTATE */



/******************
	UNKNOWNSTATE
	attempts to deduce what state we're in, if none is supplied!
	the REAL main loop.
	this is pretty much it's own, THIRD mini-state machine. 
******************/
function
unknownState($auth, $states)
{
	//confessArray($auth, "unknownstate");

	// check for valid token
	if($auth['uid'] && $auth['token']){
		user_error("unknownState(): uid and token present", E_USER_NOTICE);
		return changeState($auth, $states, 'verifytoken', 1);
	}
	
	// if there's no password stored for this user
	if($auth['uid'] && !getPass($auth['uid'])){
		user_error(
			sprintf("unknownState(): uid %d in db, but null password", 
				$auth['uid']) , 
			E_USER_NOTICE);
		return changeState($auth, $states, 'nullpass', 1);
	}

	// ok, they supplied a password. now... let's check it.
	if($auth['pwd'] && $auth['uid'] ){
		user_error(
			sprintf("unknownState(): uid %d , and pwd provided", 
				$auth['uid']) , E_USER_NOTICE );
		return changeState($auth, $states, 'checklogin', 1);
	} 

	// no pass, no token, no uid, no dice!
	if(!($auth['uid'] && $auth['pwd'])){
		user_error("unknownState(): no uid, no nothing", E_USER_NOTICE);
		//come back here after the user is done inputting data
		return changeState($auth, $states, 'needlogin', 1);
	}

	user_error("unknownState(): unhandled state! an endless loop?", 
			E_USER_ERROR);
	return changeState($auth, $states, 'needlogin', 1);
	
}/* END UNKNOWNSTATE */


/******************
	VERIFYTOKENSTATE
******************/
function
verifyTokenState($auth, $states)
{
	if(checkToken($auth['uid'], $auth['token'])){
		user_error("unknownState(): bad token", E_USER_WARNING);
		return changeState($auth, $states, 'needlogin', 1);
	}
	// wow! i'm logged in! pass token thru now that we know it's good.
	return changeState($auth, $states, 'loggedin');
}/* END VERIFYTOKENSTATE */


/******************
	CHECKLOGINSTATE
******************/
function
checkLoginState($auth, $states)
{


	// it is possible for a user to enter a password but have none in db!
	if(!getPass($auth['uid'])){
		user_error(
			sprintf("checkLoginState(): uid %d in db, but null password", 
				$auth['uid']) , 
			E_USER_NOTICE);
		return changeState($auth, $states, 'nullpass', 1);
	}

	$token = checkPass($auth['uid'], $auth['pwd']);
	if($token){
		user_error("checkLoginState(): password matches!", E_USER_NOTICE);
		//hooray!! the password is correct! pass it thru
		$newauth = changeState($auth, $states, 'loggedin', 1);
		$newauth['token'] = $token; // have to inject this manually. grr.
		return $newauth;
	}

	//incorrect password. let the pachinko machine handle it
	user_error("checkLoginState(): password does not match", E_USER_NOTICE);
	return changeState($auth, $states, 'wrongpass', 1);
}/* END CHECKLOGINSTATE */


/******************
	LOGGEDOUTSTATE
	nobody home
******************/
function
loggedOutState($auth, $states)
{

	if($auth['uid']){
		$uinfo = getUser($auth['uid']);
		$olduser = sprintf("User '%s' logged out.", $uinfo['username']);
	}

	return changeState($auth, $states, 'needlogin', 1);
	
}/* END LOGGEDOUTSTATE */


/******************
	NEEDLOGINSTATE
	we WANT someone to log in.
******************/
function
needLoginState($auth, $states)
{

	loginForm(changeState($auth, $states, 'checklogin', 1),
		'password', 
		$auth['uid'] ? 'hide' : 'show', 
		"$olduser Please log in");

	return changeState($auth, $states, 'needinput', 1);
	
}/* END NEEDLOGINSTATE */


/******************
	NULLPASSSTATE
******************/
function
nullPassState($auth, $states)
{
	$newauth = changeState($auth, $states, 'nullpass', 1);

	/* plug up security hole. in future, send them to a "changepass" state
			which will check that they know their *old* password first
	*/
	if(getPass($auth['uid'])){
		print "You have already set your password.\n";
		return changeState($auth, $states, 'needlogin', 1);
	}

	if(!$auth['pwd']){
		$uinfo = getUser($auth['uid']);
		loginForm($newauth, 'both', 'hide', 
			sprintf("<h3>Welcome %s!</h3>
				<p>This must be your first time using the new 
				password-protected version of the site. <br>
				Please choose a new password that you will 
				use for this site from now on, and type it in here.</p>", 
				$uinfo['username']));
		return changeState($auth, $states, 'needinput', 1);
	}

	// insecure, weak password
	if(weakPass($auth['pwd'])){ // NOTE this assumes a cleartext pwd!!
		return changeState($auth, $states, 'insecurepass', 1);
	}

	//no confirmation password. need one
	if(!$auth['confirm']){
		return changeState($auth, $states, 'needconfirm', 1);
	}

	// passes don't match
	// TODO: use a hash in pwd, so i'm not passing the pwd around!
	if($auth['pwd'] != $auth['confirm']){
		return changeState($auth, $states, 'confirmwrong', 1);
	}

	// wow! we made it! a good password! let's save it, shall we?
	$token = savePass($auth['uid'], $auth['pwd']);
	if($token){
		print "Your new password has been saved! <br>
				You'll need to use your password from now on 
				whenever you access this site. <br>
				Please be sure to remember it.\n";
		$newauth =  changeState($auth, $states, 'loggedin', 1);
		$newauth['token'] = $token;
	} else {
		//something eeeevil happened, send email message!
		error_log("Couldn't save password?", 1, "ken@restivo.org");
		//TODO use the custom error reporting functions
		print "Couldn't save password! 
				Something really, really bad happened.\n";
		return changeState($auth, $states, 'needlogin', 1);
	}
	return $newauth;

}/* END NULLPASSSTATE */



/******************
	NEEDCONFIRMSTATE
******************/
function
needConfirmState($auth, $states)
{
	loginForm(changeState($auth, $states, 'nullpass', 1),
			$auth['pwd'] ? 'confirm': 'both', 
			'hide', 
			"Thanks for entering your new password.
			Please type in the SAME password again one more time, 
			just to make sure.");
	return changeState($auth, $states, 'needinput', 1);
}/* END NEEDCONFIRMSTATE */



/******************
	WRONGPASSSTATE
******************/
function
wrongPassState($auth, $states)
{

	loginForm(changeState($auth, $states, 'needlogin', 1),
		'password', 'hide', 
		"Incorrect password. Please try again." );

	return changeState($auth, $states, 'needinput', 1);
}/* END  WRONGPASSSTATE */



/******************
	NOUSERSTATE
******************/
function
noUserState($auth, $states)
{
	loginForm(changeState($auth, $states, 'needlogin', 1),
		'password', 'show', "No such user. Try again.");

	return changeState($auth, $states, 'needinput', 1);
}/* END NOUSERSTATE */



/******************
	CONFIRMWRONGSTATE
******************/
function
confirmWrongState($auth, $states)
{
	loginForm(changeState($auth, $states, 'nullpass', 1),
		'both', 'hide',
		"Passwords do not match. Please try again." );

	return changeState($auth, $states, 'needinput', 1);
	
}/* END CONFIRMWRONGSTATE */



/******************
	INSECUREPASSSTATE
******************/
function
insecurePassState($auth, $states)
{
	loginForm(changeState($auth, $states, 'nullpass', 1),
			'both', 'hide',
			sprintf("Weak password, please make it at least %d letters 
					or numbers, and try again.", MIN_PASS)
	);

	return changeState($auth, $states, 'needinput', 1);
}/* END INSECUREPASSSTATE */




/******************
	LOGGEDINSTATE
******************/
function
loggedInState($auth, $states)
{
	$uinfo = getUser($auth['uid']);
	print "<table  width='100%' border=0>";
	/* trying to build a user interface out of html 
		is like trying to build a bookshelf out of mashed potatoes. 
	*/
	print "<tr>"; 
	printf("<td><h3>Welcome %s!</h3></td>\n", $uinfo['username']);
	print "<td>";
	logoutForm();
	print "</td></tr></table>";
	return changeState($auth, $states, 'loggedin', 1);
}/* END LOGGEDINSTATE */




/******************
	THRUAUTH
	passes the auth structure right through. this is VITAL for forms!
	inputs: auth, name of struct (default 'auth')
	outputs: auth as invisible fields!
******************/
function
thruAuth($auth, $newname = 'auth')
{
	if(!$auth){
		user_error("um, why was thruAuth() called with no auth!?", 
			E_USER_ERROR);
	}
	while (list($key, $val) = each($auth)){
		if($val){
			printf("<INPUT TYPE=hidden NAME='%s[%s]' VALUE='%s'>\n",
				$newname, $key, $val
			);
		}
	}
}/* END THRUAUTH  */



/******************
	WEAKPASS
	inputs: a cleartext password
	returns: 0 if ok, 1 if bad
******************/
function
weakPass($clearpass)
{
	/* XXX bug. pcre won't take /^\w{5}$/ 
			but it *will* take it WITHOUT the '$'
			weird.
	*/
	$rs = sprintf("/^\w{%d}/", MIN_PASS);
	$matches = preg_match($rs, preg_quote($clearpass));
	user_error("weakPass(): rs $rs, clearpass <$clearpass>, $matches matches", 
			E_USER_NOTICE);
	if($matches == 1){
		return 0;
	}
	return 1;
}/* END WEAKPASS */



#note bin2hex... do i need it?

?>
<!-- END AUTH -->
