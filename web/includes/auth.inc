<!-- $Id$ -->
<?php

#	functions specific to auth

#  Copyright (C) 2003  ken restivo <ken@restivo.org>
#
#  some stuff lifted from
#  POST-NUKE Content Management System
#  Copyright (C) 2001 by the Post-Nuke Development Team.
#  http://www.postnuke.com/
#  ----------------------------------------------------------------------
#  Based on:
#  PHP-NUKE Web Portal System - http://phpnuke.org/
#  Thatware - http://thatware.org/
# 
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
# 
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details. 
# 
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


require_once("movetoshared.inc");


#thank you, phpnuke
define('ACCESS_INVALID', -1);
define('ACCESS_NONE', 0);
define('ACCESS_SUMMARY', 100);
define('ACCESS_VIEW', 200);
define('ACCESS_EDIT', 500);
define('ACCESS_ADD', 600);
define('ACCESS_DELETE', 700);
define('ACCESS_ADMIN', 800);

$accessnames = array(  
		  0 => _ACCESS_NONE,
		100 => _ACCESS_SUMMARY,
		200 => _ACCESS_VIEW,
		500 => _ACCESS_EDIT,
		600 => _ACCESS_ADD,
		700 => _ACCESS_DELETE,
		800 => _ACCESS_ADMIN
);



/******************
	SAVEPASS
	commits this user's new/changed password to the database
	inputs: uid, password in clear text
	returns: a token, generated by call to generateToken()
******************/
function 
savePass($uid, $clearpass)
{
	// be paranoid
	if(!($uid && $clearpass)){
		print "savePass(): ERROR! need to pass in a uid AND a password\n";
		exit(1);
	}

	$hash = strtolower(md5($clearpass));

	$query = sprintf("update users set password = '%s' where userid = %d ",
				$hash, $uid);
	mysql_query($query);
	$err = mysql_error();
	if($err){
		//TODO: log this, don't display it
		print "savePass(): [SECRET]: $err\n";
		return 0;
	}

	print "DEBUG saving $uid, $hash, [$query]\n";
	print "Your new password is saved! Please remember it\n";
	
	return generateToken($uid, $hash);

} /* END SAVEPASS */
					


/******************
	GETPASS
	get the password hash stored for this user, 
	inputs: uid
	returns: the hash if OK, 0 if no password, or -1 if no user!
******************/
function 
getPass($uid)
{
	// sanity check
	if($uid < 1){
		print "getPass(): ERROR! $uid < 1\n";
		exit(1);
	}

	// the query
	$query = sprintf("SELECT * FROM users WHERE userid = %d ", $uid);
	#print "getPass(): [$query]\n";
	$listq = mysql_query($query);
	$err = mysql_error();
	if($err){
		#TODO: log this, don't display it
		print "getPass(): [SECRET]: $err\n";
	}
				
	while($row = mysql_fetch_assoc($listq)){
		//grab 'em all XXX is this really necessary?
		//printf("debug %s\n", $row['name']);
	}

	if (mysql_num_rows($result) > 0) {
		if($row['password']){
			print "DEBUG got one for $uid\n";
			return($row['password']); //success!
		} else {
			#print "no password\n";
			return 0; // no password entered yet for this uid
		}
	}                  

	print "DEBUG no password for $uid\n";
	return 0;
} /* END GETPASS */


/******************
	GENERATETOKEN
	inputs: uid, the hashed password from the db
	returns: a token (md5 hash of hashed passwd in db, and uid
******************/
function
generateToken($uid, $passhash)
{	
	if(!($uid && $passhash)){
		print "generateToken(): ERROR! need to pass in a uid AND a hash\n";
		exit(1);
	}
	//ok, the hash
	return strtolower(md5($uid . strtolower($passhash)));
			
}/* END GENEREATETOKEN */


/******************
	CHECKTOKEN
	check that the token is valid for this uid
	inputs: uid, token
	returns: 0 if ok, 1 if failure
******************/
function
checkToken($uid, $token)
{
	if(!($uid && $token)){
		return 1; // MUST supply both.
	}

	// seemple
	if($token == generateToken($uid, getPass($uid))){
		return 0;
	}	
	
	return 1;
}/* END CHECKTOKEN */


/******************
	CHECKAUTHLEVEL
	check that this uid is authorised to do this action
	inputs: auth structure
	returns: 0 if ok, 1 if failure
******************/
function
checkAuthLevel($auth)
{
	$uid = $auth['uid'];
	$token = $auth['token']; 
	$realm = $auth['realm'];
	$level = $auth['level'];

	confessArray($auth, "authlevel");

	if(!($uid && $realm && $token && $level)){
		print "checkAuthLevel(): ERROR not enough info\n";
		return 1;
	}

	if(($err = checkToken($uid, $token)) > 0){
		return $err;
	}

	// the query
	$query = sprintf("
			SELECT * FROM privs 
				left join users on users.userid = privs.userid
			WHERE privs.userid = %d 
				and (privs.realm = '%s' or privs.realm = 'all')
				and privs.authlevel > %d
			--",
			$uid, $realm, $level
		);
	$listq = mysql_query($query);
	$err = mysql_error();
	if($err){
		#TODO: log this, don't display it
		print "checkAuthLevel(): [SECRET]: $err\n";
	}
				
	if (mysql_num_rows($result) > 0) {
		return 0;
	}                  

	return 1;
}/* END CHECKAUTHLEVEL */



/******************
	DISPLAYLOGIN
	inputs: auth
	outputs: shows who they are logged in as, and a "logout" button
			or, a "login here" link
******************/
function
displayLogin($auth)
{

	confessArray($auth, "displaylogin");
	
	// well, they're not.
	if(!($auth['uid'] && $auth['token'])){
		printf("You are NOT logged in. <a href='%s'>Login here</a>",
			//XXX should this be menu.php?
			$_SERVER['PHP_SELF']);
		return;
	}

	// reflexively check the token first
	if(($err = checkToken($auth['uid'], $auth['token'])) > 0){
		print "displayLogin(): bad login!\n";
		return;
	}

	// the query
	$query = sprintf("
		SELECT family.name 
			FROM users 
			left join families on families.familyid = users.familyid
			WHERE users.userid = %d --",
				$auth['uid'] );
	$listq = mysql_query($query);
	$err = mysql_error();
	if($err){
		#TODO: log this, don't display it
		print "displayLogin(): [SECRET]: $err\n";
	}
				
	// sanity czech
	if (mysql_num_rows($result) < 1) {
		printf("displayLogin(): ERROR! no name for family with uid %d?\n",
			$auth['uid']);
		return;
	}

	while($row = mysql_fetch_assoc($listq)){
		$name = $row['name']; 
	}

	printf("You are logged in as %s. <a href='%s'>Logout here</a>",
		$name, $_SERVER['PHP_SELF']);

}/* END DISPLAYLOGIN */



/******************
	LOGINPOPUP
	drawing the popup
		query all users. doy.
		if an id is passed in, use that one as default. 
		otherwise, CHOOSE ONE
	inputs: uid
	outputs: renders the popup
******************/
function loginPopup($uid)
{
	print "<select name='auth[uid]' SINGLE>\n";
	print "<option value='0'>CHOOSE ONE</option>\n";

	#DO THE QUERY
	$listq = mysql_query(" select * from users order by name");
	$err = mysql_error();
	if($err){
		print "loginPopup(): [$listq]: $err\n";
	}
	while($row = mysql_fetch_array($listq)){
		$sel = $row['userid'] == $uid ? " selected" : "";
		printf("<option value='%d' %s>%s</option>\n", 
			$row['userid'], $sel, $row['name']);
 
	}
	print "\n</select>";
}/* END LOGINPOPUP */
	

/******************
	LOGIN
	the state machine
	inputs: an auth struct
	outputs: status/error messages as needed
	returns: the auth struct with necessary changes
******************/
function
logIn($auth)
{
	confessArray($auth, "logIn()");

	$states = array(
		loggedout => array (
					func => "loggedOutState",
					description => "Logged out"
					),
		nullpass => array (
					func => "nullPassState",
					required => array ( "uid", "pwd"),
					description => "User has no password in database"
					),
		wrongpass => array (
					func => "wrongPassState",
					required => array ( "uid", "pwd"),
					description => "Wrong password"
					),
		nouser => array (
					func => "noUserState",
					required => array ( "uid"),
					description => "No such user"
					),
		confirmwrong => array (
					func => "confirmWrongState",
					required => array ( "uid", "pwd", "confirm"),
					description => "Confirmation password doesn't match"
					),
		insecurepass => array (
					func => "insecurePassState",
					required => array ( "pwd"),
					description => "New password doesn't meet minimums"
					),
		loggedin => array (
					func => "loggedInState",
					required => array ( "uid", "token"),
					description => "User is logged in"
					)
	);

	fwrite(STDERR, "logIn(): entering %s\n",
		$states[$auth['state']]['description']);

	
	// sanity check the struct passed in
	while (list($key, $val) = each($states[$auth['state']['required'])){
		if(!$auth[$val]){
			fwrite(STDERR, "ERROR! $val required for state. logging out\n");
			$auth['state'] = 'loggedout'; // force it outta here
		}
	}

	// dispatch the appropriate action for this state, and collect result
	return($states[$auth['state']]['func']($auth));
	// TODO: or, do i do() while; looking for some flag in the auth?


}/* END LOGIN  */



/******************

******************/
loginForm($auth, $guts)
{
	printf("<FORM METHOD=POST ACTION='%s'>", 
					$_SERVER['PHP_SELF']);
	thruAuth($newauth);
	print $guts;
	printf("<INPUT TYPE=submit NAME='login' VALUE='LogIn'>");
    print "</FORM>";
}/* END  */



/******************
	LOGGEDOUTSTATE
	the REAL main loop.
******************/
function
loggedOutState($auth)
{
	/*
		if token/uid and they check out
			DONE state loggedin!
		if no pass (and no uid)
			show an entry form (prepop with uid if given)
			DONE
		if uid isn't real
			DONE state nouser
		if password is null
			DONE state nullpass
		if md5 of password is same as getpass()
			gen token
			DONE state loggedin!
	*/
	
}/* END  */



/******************
	NULLPASSSTATE
******************/
function
nullPassState($auth)
{
	 /* inputs password/uid
		pseudo:
			if passes don't match
				DONE state confirmwrong
			if pass is inecure
				DONE state insecurepass
			save pass, pass thru token
			DONE state loggedin!
	*/

}/* END  */



/******************
	WRONGPASSSTATE
******************/
function
wrongPassState($auth)
{
	/*
		complain.
		show the password form again, prepopulated with uid
	*/
	$newauth['state'] = "loggedout";

	return $newauth;
}/* END  */



/******************
	NOUSERSTATE
******************/
function
noUserState($auth)
{
	/*
		complain.
		show the main entry form, no prepopulation
	*/

	$newauth['state'] = "loggedout";

	return $newauth;
}/* END  */



/******************
	CONFIRMWRONGSTATE
******************/
function
confirmWrongState($auth)
{
	/*
		complain
		i know the uid, so show a form with both confirmation AND entry
	*/
	$newauth['state'] = "loggedout";
}/* END  */



/******************
	INSECUREPASSSTATE
******************/
function
insecurePassState($auth)
{
	/*
		inputs: password
		password sucks. complain. offer suggestions
		pass uid through
	*/

	$newauth['state'] = "loggedout";
}/* END  */




/******************

******************/
function
loggedInState($auth)
{
}/* END  */




/******************
	THRUAUTH
	passes the auth structure right through. this is VITAL for forms!
	inputs: auth, name of struct (default 'auth')
	outputs: auth as invisible fields!
******************/
function
thruAuth($auth, $struct = 'auth')
{
	while (list($key, $val) = each($auth)){
		printf("<INPUT TYPE=hidden NAME='%s[%s]' VALUE='%s'>\n",
			$struct, $key, $val
		);
	}
}/* END THRUAUTH  */



#note bin2hex... do i need it?

?>
<!-- END AUTH -->
