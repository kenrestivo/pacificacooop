<?php

#	functions specific to auth
#<!-- $Id$ -->
#  Copyright (C) 2003,2004  ken restivo <ken@restivo.org>
#
#  some stuff lifted from
#  POST-NUKE Content Management System
#  Copyright (C) 2001 by the Post-Nuke Development Team.
#  http://www.postnuke.com/
#  ----------------------------------------------------------------------
#  Based on:
#  PHP-NUKE Web Portal System - http://phpnuke.org/
#  Thatware - http://thatware.org/
# 
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
# 
///#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details. 
# 
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

require_once("utils.inc");

define('MIN_PASS', 5);

#thank you, phpnuke
define('ACCESS_INVALID', -1);
define('ACCESS_NONE', 0);
define('ACCESS_SUMMARY', 100);
define('ACCESS_VIEW', 200);
define('ACCESS_VIEW_MULT_HACK', 300); // hack to handle menulevel grouplevel
define('ACCESS_EDIT', 500);
define('ACCESS_ADD', 600);
define('ACCESS_DELETE', 700);
define('ACCESS_ADMIN', 800);

// the numbers, their display names, and the callback 'action' asssociated with them
$accessnames = array(  
		  0 => array('None', NULL),
		100 => array('Summarize', 'summary'),
		200 => array('View', 'view'),
		500 => array('Edit', 'edit'),
		600 => array('Create', 'add'),
		700 => array('Delete', 'confirmdelete'),
		800 => array('Administer permissions for', NULL)
);



/******************
	SAVEPASS
	commits this user's new/changed password to the database
	inputs: uid, password in clear text
	returns: a token, generated by call to generateToken()
******************/
function 
savePass($uid, $clearpass)
{
	// be paranoid
	if(!($uid && $clearpass)){
		user_error("savePass(): ERROR! need to pass in a uid AND a password\n", E_USER_ERROR);
		exit(1);
	}

	$hash = strtolower(md5($clearpass));

	$query = sprintf("update users set password = '%s' where user_id = %d ",
				$hash, $uid);
	mysql_query($query);
	$err = mysql_error();
	if($err){
		//TODO: log this, don't display it
		user_error("savePass(): [SECRET]: $err", E_USER_ERROR);
		return 0;
	}

	//user_error("saving $uid, $hash, [$query]", o);
	return generateToken($uid, $hash);

} /* END SAVEPASS */
					


/******************
	GETPASS
	get the password hash stored for this user, 
	inputs: uid
	returns: the hash if OK, 0 if no password, or -1 if no user!
******************/
function 
getPass($uid)
{
	// sanitny check
	if($uid < 1){
		user_error("getPass(): ERROR! $uid < 1",E_USER_WARNING);
		exit(1);
	}

	// the query
	$query = sprintf("SELECT * FROM users WHERE user_id = %d ", $uid);
	//user_error("getPass(): [$query]", E_USER_NOTICE);
	$listq = mysql_query($query);
	$err = mysql_error();
	if($err){
		#TODO: log this, don't display it
		user_error("getPass(): [SECRET]: $err\n", E_USER_ERROR);
	}
				
	if (mysql_num_rows($listq) > 0) {
	}                  

	while($row = mysql_fetch_assoc($listq)){
		//grab 'em all XXX is this really necessary?
		//user_error(sprintf("debug %s\n", $row['name']), E_USER_NOTICE);
		if($row['password']){
			//user_error("getPass(): got one for $uid", E_USER_NOTICE);
			return($row['password']); //success!
		} else {
			user_error("getPass(): no password for uid $uid",E_USER_NOTICE);
			return 0; // no password entered yet for this uid
		}
	}


	user_error("getPass(): no password for $uid", E_USER_NOTICE);
	return 0;
} /* END GETPASS */


/******************
	GENERATETOKEN
	inputs: uid, the hashed password from the db
	returns: a token (md5 hash of hashed passwd in db, and uid
******************/
function
generateToken($uid, $passhash)
{	
	if(!($uid && $passhash)){
		user_error("generateToken(): ERROR! need to pass in a uid AND a hash\n", 			E_USER_ERROR);
		exit(1);
	}
	//ok, the hash
	return strtolower(md5($uid . strtolower($passhash)));
			
}/* END GENEREATETOKEN */


/******************
	CHECKTOKEN
	check that the token is valid for this uid
	inputs: uid, token
	returns: 0 if ok, 1 if failure
******************/
function
checkToken($uid, $token)
{
	if(!($uid && $token)){
		return 1; // MUST supply both.
	}

	$storedpass = getPass($uid);
	if(!$storedpass){
		return 1; // no such user
	}

	// seemple
	if($token == generateToken($uid, $storedpass)){
		return 0;
	}	
	
	return 1;
}/* END CHECKTOKEN */


/******************
	CHECKPASS
	check that the cleartext password matches the md5 hash in the db
	inputs: uid, token
	returns: token if ok, 0 if failure
******************/
function
checkPass($uid, $clearpass)
{
	if(!($uid && $clearpass)){
		return 0; // MUST supply both.
	}

	$storedpass = getPass($uid);
	if(!$storedpass){
		return 0; // no such user
	}

	// passwords are stored as HASHES in database, remember?
	$md5pass = strtolower(md5($clearpass));
	//user_error("checkPass($uid, $clearpass) produces md5 of $md5pass", E_USER_NOTICE);

	if($storedpass == $md5pass){
		return generateToken($uid, $md5pass);
	}	
	
	return 0;
}/* END CHECKPASS */



/******************
	QUICKLEVELCHECK
	inputs: targetlevel, targetfamilyid, perms struct(from getAuthLevel), 
		userstruct (from getUser)
	return 0 if ok, 1 if no good
******************/
function
quickLevelCheck($targetlevel, $targetfamilyid, $permstruct, $userstruct)
{
		if(($permstruct['user_level'] >= $targetlevel  && 
			$targetfamilyid == $userstruct['family_id']) || 
			$permstruct['group_level'] >= $targetlevel) 
		{
			return 0;
		}

	return 1;
}/* END QUICKLEVELCHECK */



/******************
	CHECKAUTHLEVEL
	the highest-level function for checking authorisation
		yes/no = A(auth, family to compare to, realm, level i need, [group i need])
			check the familyid match, the level in the db, and return whatever
	inputs: auth, family to compare to, realm, level i need, [later, group ]
	returns: true if ok, false if error
******************/
function
checkAuthLevel($auth, $targetfamilyid, $targetrealm, $targetlevel, $u = null)
{
	$level = aggregateLevel($auth, $targetfamilyid, $targetrealm, $u);

	return $targetlevel <= $level ? true : false;
}/* END CHECKAUTHLEVEL */




/******************
	AGGREGATELEVEL
	return the maximum level i can get with this combination of  args
			check the familyid match, the level in the db, and return highest avail
				i.e. if my families don't match, return group level, otherwise user_level
	inputs: auth, family to compare to, realm [later group], 
	returns: max level for this action
******************/
function
aggregateLevel($auth, $targetfamilyid, $targetrealm, $u = null)
{
	$perms = getAuthLevel($auth, $targetrealm);
	is_array($u) || $u = getUser($auth['uid']);
	if(!$perms || !$u){
		return 0; //pass through the nothing.
	}

	//user_level is only relevent if i'm that family. duh
	if($targetfamilyid == $u['family_id'] ){
		$user_level = $perms['user_level'] ;
	}
	
	//i want to know the higher of the two.
	return $user_level > $perms['group_level'] ? $user_level : 
		$perms['group_level'];
	
}/* END AGGREGATELEVEL */


/******************
	GETAUTHLEVEL
		return what's up for this uid, let caller decide if that's good or bad
		checks token just so stuff doesn't sneak up on us
	inputs: auth structure,realm, and eventually group
	returns: array of user_level and grouplevel, or null if checktoken fails
******************/
function
getAuthLevel($auth, $targetrealm)
{

	//confessArray($auth, "getauthlevel");

	if(!($auth['uid'] && $targetrealm && $auth['token'] )) {
		PEAR::raiseError('not enough info', 111);
		user_error("getAuthLevel(): ERROR not enough info",E_USER_ERROR);
		return 1;
	}

	if(checkToken($auth['uid'], $auth['token'])){
		//user_error("getAuthLevel(): bad TOKEN", E_USER_WARNING);
		return 0; // bad token, no BISCUIT!
	}

	// the query
	$query = sprintf("select max(user_level) as user_level, max(group_level) as group_level, %d as user_id, realm from user_privileges left join realms on user_privileges.realm_id = realms.realm_id where realm = '%s' and (user_id = %d or (user_id is null and group_id in (select group_id from users_groups_join where user_id = %d))) group by realm",
                     $auth['uid'], 
                     mysql_real_escape_string($targetrealm),
                     $auth['uid'], 
                     $auth['uid']);
	//user_error("getAuthLevel(): [$query]: ", E_USER_NOTICE);
	$listq = mysql_query($query);
	$err = mysql_error();
	if($err){
		user_error("getAuthLevel(): [$query]: $err", E_USER_ERROR);
	}
				
	if (mysql_num_rows($listq) > 1){
		user_error(sprintf("getAuthLevel(): You may NOT have more than one entry for user_id %d and realm %s (and later, group)! The database is corrupted!", $auth['uid'], $targetrealm), 
			E_USER_ERROR);
		return 0; // there can beeee... only one!
	}                  

	while($row = mysql_fetch_assoc($listq)){
		$result['user_level'] = $row['user_level'];
		$result['group_level'] = $row['group_level'];
	}
	if(!is_array($result)){
		user_error(sprintf("getAuthLevel: NO permissions for user %d in realm %s", 
						   $auth['uid'],$targetrealm ),
				   E_USER_NOTICE); 
	}

	return $result;
}/* END GETAUTHLEVEL */



/******************
	GETUSER
	inputs: uid
	returns: returns the human name of who they are logged in, 
			and the family_id and familyname if there is one
		or 0 if none!
******************/
function
getUser($uid)
{

	if($uid < 1){
		PEAR::raiseError('ERROR! called with no uid', 666);
		user_error("getUser(): ERROR! called with no uid", E_USER_ERROR);
		return(0); // actually, it will error out
	}

	// the query
	$query = sprintf("
		SELECT users.name as username, families.name as familyname, 
				users.family_id
			FROM users 
			left join families on families.family_id = users.family_id
			WHERE users.user_id = %d ",
				$uid );
	$listq = mysql_query($query);
	$err = mysql_error();
	if($err){
		user_error("getUser(): [$query]: $err", E_USER_ERROR);
	}
				
	// sanity czech
	if (mysql_num_rows($listq) < 1) {
		user_error(
			"getUser(): ERROR [$query]! no name for family with uid $uid?", 
				E_USER_WARNING);
		return 0;
	}

	while($row = mysql_fetch_assoc($listq)){
		$savedrow = array_reverse($row); //XXX hack around mysql
	}

	return $savedrow;

}/* END GETUSER */



/******************
	ACCESSLEVELSTRING
	returns a text description of user permissions for this realm and user_level
	TODO: eventually put THIS beast into the object
		yes, callbacks are affecting this too. 
	inputs: privilege number, callbacks
	returns: text showing what the perms are in english
******************/
function
accessLevelString($privnum, $callbacks)
{
	global $accessnames;
	$i = 0;
	if(!$privnum){
		//handle 0 as special case
		return $accessnames[$privnum][0];
	}
	//this is more complex than a simple implode() ;-)
	while (list($key, $val) = each($accessnames)){
		//print "[$key] ";
		if(	$key <= $privnum && 
			$key > 0 && 
			$callbacks[$accessnames[$key][1]])
		{
			$result .= sprintf("%s%s",  $i ? ", " : "", $accessnames[$key][0]);
			$i++;
		}
	}
	reset ($accessnames);
	return $result;
}/* END ACCESSLEVELSTRING */



/******************
	LOGINPOPUP
	drawing the popup
	yes, this too is a duplicatoin of popuputil in shared.inc
		query all users. doy.
		if an id is passed in, use that one as default. 
		otherwise, CHOOSE ONE
	inputs: uid
	outputs: renders the popup
******************/
function loginPopup($uid)
{
	javaSubmit();

	print "<select name='auth[uid]'
				onchange='javascript:submitForm()'>\n";
	print "<option value='0'>CHOOSE ONE</option>\n";
	
	$sy = findSchoolYear();
	#DO THE QUERY
	// TODO: group by user_id
	$listq = mysql_query(" select * from users 
						left join kids on users.family_id = kids.family_id 
						left join enrollment on kids.kid_id = enrollment.kid_id
						where (enrollment.school_year = '$sy'
							and (enrollment.dropout_date < '2000-01-01'
							or enrollment.dropout_date is null)
							or  users.family_id < 1)
			  			group by user_id
								order by name");
	$err = mysql_error();
	if($err){
		user_error("loginPopup(): [$listq]: $err",E_USER_ERROR);
	}
	while($row = mysql_fetch_array($listq)){
		$sel = $row['user_id'] == $uid ? " selected" : "";
		printf("<option value=\"%d\" %s>%s</option>\n", 
			$row['user_id'], $sel, $row['name']);
 
	}
	print "\n</select>";
}/* END LOGINPOPUP */
	

/******************
	LOGINFORM
	inputs: auth struct, type(password, confirm, both), and user(show, hide)
	outputs: a nice login entry form.
	TODO clean this up if possible. it's ugly. but then, hey, it's html!
******************/
function
loginForm($auth, $type = 'password', $user = 'show', $statusline)
{

	// say hi.
	print "<p>$statusline</p>";

	printf("<div><FORM METHOD=POST ACTION='%s'>", 
					$_SERVER['PHP_SELF']);
	print "\n<table border=1>\n";
	//user popup (or display) stuff
	print "\n<tr>\n";
	if($user == 'show'){
		print "\t<td>Select user name:\n</td>\n";
		print "\t<td>";
		loginPopup($auth['uid']);
		print "</td>\n";
	} else {
		$u = getUser($auth['uid']);
		printf("\n<td>Logging in %s...</td>\n", $u['username']);
	}
	print "</tr>\n";

	//password stuff
	print "\n<tr>\n";
	if($type == 'password' || $type == 'both'){
		if($type == 'both'){ //XXX hack. i can't pass the REAL state thru.
			print "<td>Please type in your new password here: </td>\n";
		} else {
			print "\t<td>Enter password 
				(or type in a new password if you don't have one yet): </td>\n";
		}
		print "\t<td><INPUT TYPE=password NAME='auth[pwd]'></td>\n";
	}
	print "</tr>\n";

	//confirm stuff

	if($type == 'confirm' || $type == 'both'){
		print "\n<tr>\n";
		print "\t<td>Please re-type your password to confirm it: </td>\n";
		print "\t<td><INPUT TYPE=password NAME='auth[confirm]'></td>\n";
		print "</tr>\n";
	}


	print "\n</table>\n";

	/* NOTE! thruAuth MUST be here at the bottom of the form! 
		if i put it at the top of the form, then SID is set for some reason
		(GODDAMNED PHP SESSION MAGIC!) and i end up passing cookie auths as vars.
		VERY stupid, very unnecessary, very bug-causing.
	*/
	if($auth){ 
		thruAuth($auth);
	}

	printf("<INPUT TYPE=submit NAME='login' VALUE='%s'>",
		$type == 'confirm' || $type == 'both' ? 'Save New Password' : 'Log In');
	printf("<INPUT TYPE=submit NAME='logout' VALUE='Cancel'>");
    print "</FORM></div>";
}/* END LOGINFORM */


/******************
	LOGIN
	this logs the user in. it is the main() entry point into auth stuff
	the state machine
		only returns if it either needs more user input or is finished!
		if it returns without state == 'loggedin', caller wants to done()
	inputs: HTTP_VARS
	outputs: status/error messages as needed
	returns: the auth struct with necessary changes
******************/
function
logIn($vars)
{
	//confessArray($vars, 'logIn($vars) called with');

	/* vital information for each state.
		func = callback function for this state
		required = mandatory elements of the auth structure for this state
		wanted = optional elements of the auth structure for this state
		terminus = if we reach this state, exit the state machine
		description = some debug/explanatory text. not used right now
	*/
	$states = array(
		unknown => array (
					func => "unknownState",
					wanted => array ( "uid", "pwd", "confirm"), //XXX token?
					description => "Indeterminate state."
					),
		needlogin => array (
					func => "needLoginState",
					wanted => array ( "uid"),
					description => "You must log in, but you haven't yet"
					),
		loggedout => array (
					func => "loggedOutState",
					description => "Forcibly and deliberately logged out"
					),
		nullpass => array (
					func => "nullPassState",
					required => array ( "uid"),
					wanted => array ( "pwd", "confirm"),
					description => "User has no password in database"
					),
		checklogin => array (
					func => "checkLoginState",
					required => array ("uid"),
					wanted => array ("pwd"),
					description => "Checking password"
					),
		verifytoken => array (
					func => "verifyTokenState",
					required => array ( "uid", "token"),
					description => "Checking token"
					),
		wrongpass => array (
					func => "wrongPassState",
					required => array ( "uid"),
					description => "Wrong password"
					),
		nouser => array (
					func => "noUserState",
					required => array ( "uid"),
					description => "No such user"
					),
		needconfirm => array (
					func => "needConfirmState",
					required => array ( "uid", "pwd"),
					description => "Need new password confirmed"
					),
		confirmwrong => array (
					func => "confirmWrongState",
					required => array ( "uid"),
					description => "Confirmation password doesn't match"
					),
		insecurepass => array (
					func => "insecurePassState",
					required => array ( "uid", "pwd"),
					description => "New password doesn't meet minimums"
					),
		loggedin => array (
					terminus => "yes",
					func => "loggedInState",
					required => array ( "uid", "token"),
					description => "User is logged in"
					),
		needinput => array (
					terminus => "yes",
					description => "UI needs input. Exit state machine."
					)
	);

	$savedauth = $_SESSION['auth'];

	//confessArray($vars, "login(vars)");
	//confessArray($savedauth, "login(savedauth)");
	
	$auth = changeState($vars['auth'], $states, 
		$savedauth['state'] ? $savedauth['state'] : 'unknown',
		1, $savedauth);
 
	//force us to drop all previous state if 'cancel' button pressed!
	if($vars['logout'] || $vars['action'] == 'logout'){
		$auth['state'] = 'loggedout';
	}

	// deal with nothing passed in
	if(!$auth){
		$auth = array( state => 'unknown' );
	}
	if(!$auth['state']){
		$auth['state'] == 'unknown';
	}

	//confessArray($auth, "login(auth)");

	//if they have cookie problems, let's find out NOW!
	checkSessionId($auth);
	
	/* start the pachinko machine. 
		no way out unless user input needed, or success */

	do{

		// are all our required inputs present?
		$auth = sanityCheck($auth, $states);

		$state = $auth['state']; // easier on the eyes!

		user_error("logIn(): dispatching to $state", E_USER_NOTICE);

		/* confessArray($auth, sprintf("login() calling %s() with", 
				$states[$state]['func'] )); 
		*/

		// dispatch the appropriate action for this state, and collect result
		$func = $states[$state]['func'];
		if($func){
			// we want the func. gotta have the func. yowwww...
			$auth = $func($auth, $states);
		}
	} while(!$states[$state]['terminus']);


	return($auth);

}/* END LOGIN  */


/******************
	SANITYCHECK
	make sure a state has the minimum inputs required for it
	inputs: an auth struct, and a states struct to compare it to
	returns: the auth struct, with new state if needed
******************/
function
sanityCheck($auth, $states)
{
	$state = $auth['state'];
	if(!$states[$state]){
			user_error("sanityCheck(): $state is an illegal state. Forcing unknown state", 
				E_USER_WARNING);
			// NOTE! i do NOT use changeState() here
			$auth['state'] = 'unknown'; // force it outta here
	}
	if ($states[$state]['required']){
		while (list($key, $val) = each($states[$state]['required'])){
			if(!$auth[$val]){
				//serious. potential security violation.
				user_error("sanityCheck(): $val required for state $state. Forcing 'unknown' state.", E_USER_WARNING);
				$auth['state'] = 'unknown'; // force it outta here
			}
		}
		reset($auth);
	}


	//check that uid is valid, if supplied
	if($auth['uid'] && !getUser($auth['uid'])){
		user_error(
			sprintf("unknownState(): uid %d present, but user not in db", 
				$auth['uid'])
		, E_USER_NOTICE);
		$auth['state'] = 'nouser'; // force it outta here
	}

	return $auth;
}/* END SANITYCHECK */


/******************
	CHANGESTATE
	utility function, kind of like a copy/constructor method
	makes a copy of an auth struct passed in, copying required fields in
		or, optionally, the wanted fields too
		and changes its state to the one passed in
	inputs: auth struct, states struct, new state, and 'wanted' flag
	returns: a copy of the struct with changes as above
******************/
function
changeState($auth, $states, $newstate, $wanted = 0, $savedauth = NULL)
{
	$newauth = array( state => $newstate );

	if($states[$newstate]['required']){
		while (list($key, $val) = each($states[$newstate]['required'])){
			if($savedauth && $savedauth[$val]){
				user_error(sprintf("changeState(%s): keeping saved %s auth[%s] = %s", 
					$newstate, "required", $val, $savedauth[$val]), 
						E_USER_NOTICE);
				$newauth[$val] = $savedauth[$val];
			} else if($auth[$val]){
				user_error(sprintf("changeState(%s): keeping passed %s auth[%s] = %s", 
					$newstate, "required" , $val, $auth[$val]), 
						E_USER_NOTICE);
				$newauth[$val] = $auth[$val];
			}
		}
	}

	if($wanted && $states[$newstate]['wanted']){
		while (list($key, $val) = each($states[$newstate]['wanted'])){
			if($savedauth && $savedauth[$val]){
				user_error(sprintf("changeState(%s): keeping saved %s auth[%s] = %s", 
					$newstate, "wanted", $val, $savedauth[$val] ), 
						E_USER_NOTICE);
				$newauth[$val] = $savedauth[$val];
			} else if($auth[$val]){
				user_error(sprintf("changeState(%s): keeping passed %s auth[%s] = %s ", 
					$newstate, "required", $val, $savedauth[$val]), 
						E_USER_NOTICE);
				$newauth[$val] = $auth[$val];
			}
		}
	}

	//clean up the mess we made
	$auth && reset($auth);
	$savedauth && reset($savedauth);
	reset($states);

	return $newauth;
		
}/* END CHANGESTATE */



/******************
	UNKNOWNSTATE
	attempts to deduce what state we're in, if none is supplied!
	the REAL main loop.
	this is pretty much it's own, THIRD mini-state machine. 
******************/
function
unknownState($auth, $states)
{
	//confessArray($auth, "unknownstate");

	// check for valid token
	if($auth['uid'] && $auth['token']){
		user_error("unknownState(): uid and token present", E_USER_NOTICE);
		return changeState($auth, $states, 'verifytoken', 1);
	}
	
	// if there's no password stored for this user
	if($auth['uid'] && !getPass($auth['uid'])){
		user_error(
			sprintf("unknownState(): uid %d in db, but null password", 
				$auth['uid']) , 
			E_USER_NOTICE);
		return changeState($auth, $states, 'nullpass', 1);
	}

	// ok, they supplied a password. now... let's check it.
	if($auth['pwd'] && $auth['uid'] ){
		user_error(
			sprintf("unknownState(): uid %d , and pwd provided", 
				$auth['uid']) , E_USER_NOTICE );
		return changeState($auth, $states, 'checklogin', 1);
	} 

	// no pass, no token, no uid, no dice!
	if(!($auth['uid'] && $auth['pwd'])){
		user_error("unknownState(): no uid, no nothing", E_USER_NOTICE);
		//come back here after the user is done inputting data
		return changeState($auth, $states, 'needlogin', 1);
	}

	user_error("unknownState(): unhandled state! an endless loop?", 
			E_USER_ERROR);
	return changeState($auth, $states, 'needlogin', 1);
	
}/* END UNKNOWNSTATE */


/******************
	VERIFYTOKENSTATE
******************/
function
verifyTokenState($auth, $states)
{
	if(checkToken($auth['uid'], $auth['token'])){
		user_error("unknownState(): bad token", E_USER_WARNING);
		return changeState($auth, $states, 'needlogin', 1);
	}
	// wow! i'm logged in! pass token thru now that we know it's good.
	return changeState($auth, $states, 'loggedin');
}/* END VERIFYTOKENSTATE */


/******************
	CHECKLOGINSTATE
******************/
function
checkLoginState($auth, $states)
{

	// it is possible for a user to enter a password but have none in db!
	if(!getPass($auth['uid'])){
		user_error(
			sprintf("checkLoginState(): uid %d in db, but null password", 
				$auth['uid']) , 
			E_USER_NOTICE);
		return changeState($auth, $states, 'nullpass', 1);
	}

	//with new javascript thing, they may put in a BLANK password.
	if(!$auth['pwd']){
		user_error(
			sprintf("checkLoginState(): uid %d  but null password", 
				$auth['uid']) , 
			E_USER_NOTICE);
		//just loop around!
		return changeState($auth, $states, 'needlogin', 1);
	}

	$token = checkPass($auth['uid'], $auth['pwd']);
	if($token){
		user_error("checkLoginState(): password matches!", E_USER_NOTICE);
		//hooray!! the password is correct! pass it thru
		$newauth = changeState($auth, $states, 'loggedin', 1);
		$newauth['token'] = $token; // have to inject this manually. grr.
		return $newauth;
	}

	//incorrect password. let the pachinko machine handle it
	user_error("checkLoginState(): password does not match", E_USER_NOTICE);
	return changeState($auth, $states, 'wrongpass', 1);
}/* END CHECKLOGINSTATE */


/******************
	LOGGEDOUTSTATE
	nobody home
******************/
function
loggedOutState($auth, $states)
{


	if($auth['uid']){
		$uinfo = getUser($auth['uid']);
		$olduser = sprintf("User '%s' logged out.", $uinfo['username']);
	}

	//DO NOT destroy th session here!! just wipe auth. read docs.
	$auth['uid']  = 0;
	$_SESSION['auth'] = NULL;

	return changeState($auth, $states, 'needlogin', 1);
	
}/* END LOGGEDOUTSTATE */


/******************
	NEEDLOGINSTATE
	we WANT someone to log in.
******************/
function
needLoginState($auth, $states)
{

	loginForm(changeState($auth, $states, 'checklogin', 1),
		'password', 
		$auth['uid'] ? 'hide' : 'show', 
		"Please log in");

	return changeState($auth, $states, 'needinput', 1);
	
}/* END NEEDLOGINSTATE */


/******************
	NULLPASSSTATE
******************/
function
nullPassState($auth, $states)
{
	$newauth = changeState($auth, $states, 'nullpass', 1);

	/* plug up security hole. in future, send them to a "changepass" state
			which will check that they know their *old* password first
	*/
	if(getPass($auth['uid'])){
		print "You have already set your password.\n";
		return changeState($auth, $states, 'needlogin', 1);
	}

	if(!$auth['pwd']){
		$uinfo = getUser($auth['uid']);
		loginForm($newauth, 'both', 'hide', 
			sprintf("<h3>Welcome %s!</h3>
				<p>This must be your first time using the new 
				password-protected version of the site. <br>
				Please choose a new password that you will 
				use for this site from now on, and type it in here.</p>", 
				$uinfo['username']));
		return changeState($auth, $states, 'needinput', 1);
	}

	// insecure, weak password
	if(weakPass($auth['pwd'])){ // NOTE this assumes a cleartext pwd!!
		return changeState($auth, $states, 'insecurepass', 1);
	}

	//no confirmation password. need one
	if(!$auth['confirm']){
		return changeState($auth, $states, 'needconfirm', 1);
	}

	// passes don't match
	// TODO: use a hash in pwd, so i'm not passing the pwd around!
	if($auth['pwd'] != $auth['confirm']){
		return changeState($auth, $states, 'confirmwrong', 1);
	}

	// wow! we made it! a good password! let's save it, shall we?
	$token = savePass($auth['uid'], $auth['pwd']);
	if($token){
		print "Your new password has been saved! <br>
				You'll need to use your password from now on 
				whenever you access this site. <br>
				Please be sure to remember it.\n";
		$newauth =  changeState($auth, $states, 'loggedin', 1);
		$newauth['token'] = $token;
	} else {
		//something eeeevil happened, send email message!
		error_log("Couldn't save password?", 1, "ken@restivo.org");
		//TODO use the custom error reporting functions
		print "Couldn't save password! 
				Something really, really bad happened.\n";
		return changeState($auth, $states, 'needlogin', 1);
	}
	return $newauth;

}/* END NULLPASSSTATE */



/******************
	NEEDCONFIRMSTATE
******************/
function
needConfirmState($auth, $states)
{
	loginForm(changeState($auth, $states, 'nullpass', 1),
			$auth['pwd'] ? 'confirm': 'both', 
			'hide', 
			"Thanks for entering your new password.
			Please type in the SAME password again one more time, 
			just to make sure.");
	return changeState($auth, $states, 'needinput', 1);
}/* END NEEDCONFIRMSTATE */



/******************
	WRONGPASSSTATE
******************/
function
wrongPassState($auth, $states)
{

	$auth['pwd'] = $auth['confirm'] = NULL;
	loginForm(changeState($auth, $states, 'needlogin', 1),
		'password', 'hide', 
		"<span color='#ff0000'>Incorrect password</span>. You already have a password in the system, and what you typed isn't it. Please try again.</p><p>Helpful hints:</p><ul class=normal><li>Check your CAPS LOCK key.</li><li>Your husband, wife, or partner may already have entered a password for you. You may want to ask him or her.</li><li>Finally, people forget their passwords. A lot. If you've forgotten, email or call and we'll reset it for you.</li></ul>" );

	return changeState($auth, $states, 'needinput', 1);
}/* END  WRONGPASSSTATE */



/******************
	NOUSERSTATE
******************/
function
noUserState($auth, $states)
{
	loginForm(changeState($auth, $states, 'needlogin', 1),
		'password', 'show', "No such user. Try again.");

	return changeState($auth, $states, 'needinput', 1);
}/* END NOUSERSTATE */



/******************
	CONFIRMWRONGSTATE
******************/
function
confirmWrongState($auth, $states)
{
	$auth['pwd'] = $auth['confirm'] = NULL; //explicitly whack!
	loginForm(changeState($auth, $states, 'nullpass', 1),
		'both', 'hide',
		"Passwords do not match. Please try again." );

	return changeState($auth, $states, 'needinput', 1);
	
}/* END CONFIRMWRONGSTATE */



/******************
	INSECUREPASSSTATE
******************/
function
insecurePassState($auth, $states)
{
	$auth['pwd'] = $auth['confirm'] = NULL; //explicitly whack!
	loginForm(changeState($auth, $states, 'nullpass', 1),
			'both', 'hide',
			sprintf("Weak password, please make it at least %d letters 
					or numbers, and try again.", MIN_PASS)
	);

	return changeState($auth, $states, 'needinput', 1);
}/* END INSECUREPASSSTATE */




/******************
	LOGGEDINSTATE
	i am me. 
	i do *not* want this to evolve (devolve?) into a menu system
******************/
function
loggedInState($auth, $states)
{
	$newauth =  changeState($auth, $states, 'loggedin', 1);
	$_SESSION['auth'] = $newauth; // save it!
	return  $newauth;
}/* END LOGGEDINSTATE */




/******************
	THRUAUTH
	used for cases where i have a FORM (POST), 
		and can't use SID (GET) constant.
	inputs: none
	outputs: session id as invisible fields!
******************/
function
thruAuth($auth)
{
	$sid = thruAuthCore($auth);
	if($sid){
		printf("<INPUT TYPE=hidden NAME='%s' VALUE='%s'>\n",
					   'coop',  $sid);
	}
}/* END THRUAUTH  */

function
thruAuthCore($auth)
{
	if(!is_array($auth)){
		user_error("thruAuthCore($auth): is not an array. that would reset the session, and that would be bad. cowardly refusing to do so.", E_USER_ERROR);
	}

	$_SESSION['auth'] = $auth;

	if(SID){
		return session_id();
	}
	return false;

}/* END THRUAUTHCORE  */




/******************
	WEAKPASS
	inputs: a cleartext password
	returns: 0 if ok, 1 if bad
******************/
function
weakPass($clearpass)
{
	/* XXX bug. pcre won't take /^\w{5}$/ 
			but it *will* take it WITHOUT the '$'
			weird.
	*/
	$rs = sprintf("/^\w{%d}/", MIN_PASS);
	$matches = preg_match($rs, preg_quote($clearpass));
	user_error("weakPass(): rs $rs, clearpass <$clearpass>, $matches matches", 
			E_USER_NOTICE);
	if($matches == 1){
		return 0;
	}
	return 1;
}/* END WEAKPASS */



/******************
	DISPLAYAUTH
	useful in view reports
	TODO may need to move this to the shared.inc, 
		because it needs to know about callbacks
		not a problem now, but when we go object-oriented, it will be
	inputs: privs struct, user struct, realm, pretty nae
******************/
function
displayAuth($p, $u, $callbacks)
{
	$realm = $callbacks['realm'];
	$pretty = $callbacks['description'];

	print "<h3>$pretty \n";
	if($p['group_level'] < ACCESS_VIEW){
		printf("for the %s Family. </h3>
				<p>(You are authorized to %s %s for the %s).</p>\n", 
			$u['familyname'], 
			accessLevelString($p['user_level'], $callbacks),
			$pretty,
			$u['username']
		);
	} else {
		printf("for ALL users.</h3>
				<p>(%s is authorized to %s %s
				for ALL families).</p>",
			$u['username'],
			accessLevelString($p['group_level'], $callbacks),
			$pretty);
	}

}/* END DISPLAYAUTH */


/******************
	FIELDPERMS
	inputs: a perms sturcture (array of group, user levels for this field),
		a perms structure, a user structure, and the level to test against
	returns: 0 if permitted, 1 if not
******************/
function
fieldPerms($perms, $targetfamilyid, $p, $u, $targetlevel)
{

	// no perms? no problem! default is i don't care.
	if(!is_array($perms)){
		user_error("fieldPerms(): no perms, using default (ACCEPT)", E_USER_NOTICE);
		return 0;
	}

	user_error(sprintf("fieldPerms(): targetfamily %d, actualfamilyid %d, targetlevel %d, fieldgroup %d, actualgroup %d, fielduser %d, actualuser %d", $targetfamilyid, $u['family_id'], $targetlevel,
		$perms[0], $p['group_level'], $perms[1], $p['user_level'] ), 
		E_USER_NOTICE);

	//the LESSER of two evils
	$user =  $p['user_level'] > $perms[1] ? $perms[1] : $p['user_level'];
	$group = $p['group_level'] > $perms[0] ? $perms[0] : $p['group_level'];

	//if it's MY record, return the user_level, otherwise the group_level.
	if($group >= $targetlevel ||
			($targetfamilyid == $u['family_id'] && $user >= $targetlevel ) ) 
	{
		user_error("fieldPerms(): ACCEPTING", E_USER_NOTICE);
		return 0;
	}

	user_error("fieldPerms(): REJECTING", E_USER_NOTICE);
	return 1;
	
}/* END FIELDPERMS */


/******************
	CHECKSESSIONID
	puke if there's some evil cookie problem
	inputs: an auth
	outputs: a message if no session id is present
******************/
function
checkSessionId($auth)
{
	if(!session_id()){
		print "<br>This web site, just like our kids, needs cookies in order to function.
				<br>ME WANT COOKIE!!!!!
				<br>Please either:
				<li>Turn on cookies in your browser
				<li>Enable cookies for this site (check its 'security settings')
				<li>Upgrade your browser if 
						you have an old one that doesn't support cookies
				<li>Try reloading this page, or typing in the URL manually
				<br>If it still doesn't work, call us. 
						Something may be wrong that we need to fix.
				";
		done();
	}	
}/* END CHECKSESSIONID */



#note bin2hex... do i need it?

?>