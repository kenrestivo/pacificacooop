<!-- $Id$ -->
<?php

#	functions specific to auth

#  Copyright (C) 2003  ken restivo <ken@restivo.org>
#
#  some stuff lifted from
#  POST-NUKE Content Management System
#  Copyright (C) 2001 by the Post-Nuke Development Team.
#  http://www.postnuke.com/
#  ----------------------------------------------------------------------
#  Based on:
#  PHP-NUKE Web Portal System - http://phpnuke.org/
#  Thatware - http://thatware.org/
# 
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
# 
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details. 
# 
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


require_once("movetoshared.inc");


#thank you, phpnuke
define('ACCESS_INVALID', -1);
define('ACCESS_NONE', 0);
define('ACCESS_SUMMARY', 100);
define('ACCESS_VIEW', 200);
define('ACCESS_EDIT', 500);
define('ACCESS_ADD', 600);
define('ACCESS_DELETE', 700);
define('ACCESS_ADMIN', 800);

$accessnames = array(  
		  0 => _ACCESS_NONE,
		100 => _ACCESS_SUMMARY,
		200 => _ACCESS_VIEW,
		500 => _ACCESS_EDIT,
		600 => _ACCESS_ADD,
		700 => _ACCESS_DELETE,
		800 => _ACCESS_ADMIN
);



/******************
	SAVEPASS
	commits this user's new/changed password to the database
	inputs: uid, password in clear text
	returns: a token, generated by call to generateToken()
******************/
function 
savePass($uid, $clearpass)
{
	// be paranoid
	if(!($uid && $clearpass)){
		error_log("savePass(): ERROR! need to pass in a uid AND a password\n", 0);
		exit(1);
	}

	$hash = strtolower(md5($clearpass));

	$query = sprintf("update users set password = '%s' where userid = %d ",
				$hash, $uid);
	mysql_query($query);
	$err = mysql_error();
	if($err){
		//TODO: log this, don't display it
		error_log("savePass(): [SECRET]: $err", 0);
		return 0;
	}

	//error_log("saving $uid, $hash, [$query]", o);
	print "Your new password is saved! Please remember it\n";
	
	return generateToken($uid, $hash);

} /* END SAVEPASS */
					


/******************
	GETPASS
	get the password hash stored for this user, 
	inputs: uid
	returns: the hash if OK, 0 if no password, or -1 if no user!
******************/
function 
getPass($uid)
{
	// sanitny check
	if($uid < 1){
		error_log("getPass(): ERROR! $uid < 1",0);
		exit(1);
	}

	// the query
	$query = sprintf("SELECT * FROM users WHERE userid = %d ", $uid);
	//error_log("getPass(): [$query]", 0);
	$listq = mysql_query($query);
	$err = mysql_error();
	if($err){
		#TODO: log this, don't display it
		error_log("getPass(): [SECRET]: $err\n", 0);
	}
				
	if (mysql_num_rows($listq) > 0) {
	}                  

	while($row = mysql_fetch_assoc($listq)){
		//grab 'em all XXX is this really necessary?
		//error_log(sprintf("debug %s\n", $row['name']), 0);
		if($row['password']){
			error_log("getPass(): got one for $uid", 0);
			return($row['password']); //success!
		} else {
			error_log("getPass(): no password for uid $uid",0);
			return 0; // no password entered yet for this uid
		}
	}


	error_log("getPass(): no password for $uid", 0);
	return 0;
} /* END GETPASS */


/******************
	GENERATETOKEN
	inputs: uid, the hashed password from the db
	returns: a token (md5 hash of hashed passwd in db, and uid
******************/
function
generateToken($uid, $passhash)
{	
	if(!($uid && $passhash)){
		error_log("generateToken(): ERROR! need to pass in a uid AND a hash\n");
		exit(1);
	}
	//ok, the hash
	return strtolower(md5($uid . strtolower($passhash)));
			
}/* END GENEREATETOKEN */


/******************
	CHECKTOKEN
	check that the token is valid for this uid
	inputs: uid, token
	returns: 0 if ok, 1 if failure
******************/
function
checkToken($uid, $token)
{
	if(!($uid && $token)){
		return 1; // MUST supply both.
	}

	$storedpass = getPass($uid);
	if(!$storedpass){
		return 1; // no such user
	}

	// seemple
	if($token == generateToken($uid, $storedpass)){
		return 0;
	}	
	
	return 1;
}/* END CHECKTOKEN */


/******************
	CHECKPASS
	check that the token is valid for this uid
	inputs: uid, token
	returns: token if ok, 0 if failure
******************/
function
checkPass($uid, $clearpass)
{
	if(!($uid && $clearpass)){
		return 0; // MUST supply both.
	}

	$storedpass = getPass($uid);
	if(!$storedpass){
		return 0; // no such user
	}

	// passwords are stored as HASHES in database, remember?
	$md5pass = strtolower(md5($clearpass));
	//error_log("checkPass($uid, $clearpass) produces md5 of $md5pass", 0);

	if($storedpass == $md5pass){
		return generateToken($uid, $md5pass);
	}	
	
	return 0;
}/* END CHECKPASS */


/******************
	CHECKAUTHLEVEL
	check that this uid is authorised to do this action
	inputs: auth structure
	returns: 0 if ok, 1 if failure
******************/
function
checkAuthLevel($auth)
{

	confessArray($auth, "authlevel");

	if(!($auth['uid'] && $auth['realm'] && 
			$auth['token'] && $auth['level']))
	{
		error_log("checkAuthLevel(): ERROR not enough info",0);
		return 1;
	}

	if(($err = checkToken($auth['uid'], $auth['token'])) > 0){
		return $err;
	}

	// the query
	$query = sprintf("
			SELECT * FROM privs 
				left join users on users.userid = privs.userid
			WHERE privs.userid = %d 
				and (privs.realm = '%s' or privs.realm = 'all')
				and privs.authlevel > %d
			--",
			$auth['uid'], $auth['realm'], $auth['level']
		);
	$listq = mysql_query($query);
	$err = mysql_error();
	if($err){
		#TODO: log this, don't display it
		error_log("checkAuthLevel(): [SECRET]: $err",0);
	}
				
	if (mysql_num_rows($listq) > 0) {
		return 0;
	}                  

	return 1;
}/* END CHECKAUTHLEVEL */



/******************
	GETUSER
	inputs: uid
	returns: returns the human name of who they are logged in, 
			and the familyid and familyname if there is one
		or 0 if none!
******************/
function
getUser($uid)
{

	if($uid < 1){
		error_log("ERROR! no uid", 0);
		exit(1);
	}

	// the query
	$query = sprintf("
		SELECT users.name as username, families.name as familyname, 
				users.familyid
			FROM users 
			left join families on families.familyid = users.familyid
			WHERE users.userid = %d ",
				$uid );
	$listq = mysql_query($query);
	$err = mysql_error();
	if($err){
		error_log("getUser(): [$query]: $err", 0);
	}
				
	// sanity czech
	if (mysql_num_rows($listq) < 1) {
		error_log(
			"getUser(): ERROR [$query]! no name for family with uid $uid?", 0);
		return 0;
	}

	while($row = mysql_fetch_assoc($listq)){
		$savedrow = array_reverse($row); //XXX hack around mysql
	}

	return $savedrow;

}/* END GETUSER */



/******************
	LOGINPOPUP
	drawing the popup
		query all users. doy.
		if an id is passed in, use that one as default. 
		otherwise, CHOOSE ONE
	inputs: uid
	outputs: renders the popup
******************/
function loginPopup($uid)
{
	print "<select name='auth[uid]' SINGLE>\n";
	print "<option value='0'>CHOOSE ONE</option>\n";

	#DO THE QUERY
	$listq = mysql_query(" select * from users order by name");
	$err = mysql_error();
	if($err){
		error_log("loginPopup(): [$listq]: $err",0);
	}
	while($row = mysql_fetch_array($listq)){
		$sel = $row['userid'] == $uid ? " selected" : "";
		printf("<option value='%d' %s>%s</option>\n", 
			$row['userid'], $sel, $row['name']);
 
	}
	print "\n</select>";
}/* END LOGINPOPUP */
	

/******************
	LOGINFORM
	inputs: auth struct, type(password, confirm, both), and user(show, hide)
	outputs: a nice login entry form.
	TODO clean this up if possible. it's ugly. but then, hey, it's html!
******************/
function
loginForm($auth, $type = 'password', $user = 'show', $statusline)
{

	// say hi.
	print "<p>$statusline</p>";

	printf("<FORM METHOD=POST ACTION='%s'>", 
					$_SERVER['PHP_SELF']);
	thruAuth($auth);
	//user popup (or display) stuff
	if($user == 'show'){
		print "Select user name: \n";
		loginPopup($auth['uid']);
	} else {
		$u = getUser($auth['uid']);
		printf("Logging in %s...\n", $u['username']);
	}

	//password stuff
	if($type == 'password' || $type == 'both'){
		if($type == 'both'){ //XXX hack. i can't pass the REAL state thru.
			print "Please choose a new password and type it here: \n";
		} else {
			print "Enter password: \n";
		}
		print "<INPUT TYPE=password NAME='auth[pwd]'>";
	}

	//confirm stuff
	if($type == 'confirm' || $type == 'both'){
		print "Please re-type your password to confirm it: \n";
		print "<INPUT TYPE=password NAME='auth[confirm]'>";
	}

	printf("<INPUT TYPE=submit NAME='login' VALUE='LogIn'>");
	printf("<INPUT TYPE=submit NAME='cancel' VALUE='Cancel'>");
    print "</FORM>";
}/* END LOGINFORM */


/******************
	LOGIN
	the state machine
		only returns if it either needs more user input or is finished!
		if it returns without state == 'loggedin', caller wants to done()
	inputs: an auth struct
	outputs: status/error messages as needed
	returns: the auth struct with necessary changes
******************/
function
logIn($auth)
{
	//confessArray($auth, 'logIn($auth) called with');

	// vital information for each state.
	$states = array(
		unknown => array (
					func => "unknownState",
					description => "Indeterminate state."
					),
		loggedout => array (
					func => "loggedOutState",
					want => array ( "uid"),
					description => "Logged out"
					),
		nullpass => array (
					func => "nullPassState",
					required => array ( "uid"),
					want => array ( "pwd", "confirm"),
					description => "User has no password in database"
					),
		wrongpass => array (
					func => "wrongPassState",
					required => array ( "uid"),
					description => "Wrong password"
					),
		nouser => array (
					func => "noUserState",
					required => array ( "uid"),
					description => "No such user"
					),
		needconfirm => array (
					func => "needConfirmState",
					required => array ( "uid", "pwd"),
					description => "Need new password confirmed"
					),
		confirmwrong => array (
					func => "confirmWrongState",
					required => array ( "uid"),
					description => "Confirmation password doesn't match"
					),
		insecurepass => array (
					func => "insecurePassState",
					required => array ( "pwd"),
					description => "New password doesn't meet minimums"
					),
		loggedin => array (
					func => "loggedInState",
					required => array ( "uid", "token"),
					description => "User is logged in"
					)
	);

	// deal with nothing passed in
	if(!$auth['state']){
		$auth['state'] == 'unknown';
	}
	if(!$auth){
		$auth = array( state => 'unknown' );
	}

	
	/* start the pachinko machine. 
		no way out unless user input needed, or success */
	do {


		// are all our required inputs present?
		$auth = sanityCheck($auth, $states);

		$state = $auth['state']; // easier on the eyes!

		error_log("logIn(): in $state", 0);

		/* confessArray($auth, sprintf("login() calling %s() with", 
				$states[$state]['func'] )); 
		*/

		// dispatch the appropriate action for this state, and collect result
		$auth = $states[$state]['func']($auth);

	} while ($auth['state'] != "needinput" && $auth['state'] != 'loggedin');

	return($auth);

}/* END LOGIN  */


/******************
	SANITYCHECK
	make sure a state has the minimum inputs required for it
	inputs: an auth struct, and a states struct to compare it to
	returns: the auth struct, with new state if needed
******************/
function
sanityCheck($auth, $states)
{
	$state = $auth['state'];
	// TODO: turn this into a proper state!! maybe, "botched"?
	if ($states[$state]['required']){
		while (list($key, $val) = each($states[$state]['required'])){
			if(!$auth[$val]){
				/* TODO maybe report this to the user? 
						or, if i'm being hacked, not?
				print "Security violation occurred. You've been logged out.";
				*/
				error_log("sanityCheck(): ERROR! $val required for state $state. logging out", 0);
				$auth['state'] = 'loggedout'; // force it outta here
			}
		}
		reset($auth);
	}
	return $auth;
}/* END SANITYCHECK */



/******************
	UNKNOWNSTATE
	the REAL main loop.
	this is pretty much it's own, THIRD mini-state machine. 
******************/
function
unknownState($auth)
{
	$newauth = array(
			state => 'loggedout'
	);

	//confessArray($newauth, "loggedoutstate");

	// check for valid token
	if($auth['uid'] && $auth['token']){
		error_log("unknownState(): uid and token present", 0);
		$newauth['uid'] = $auth['uid'];
		if(checkToken($auth['uid'], $auth['token'])){
			error_log("unknownState(): bad token", 0);
			$newauth['state'] = 'loggedout'; 
			return $newauth;
		}
		// wow! i'm logged in! pass token thru now that we know it's good.
		$newauth['token'] = $auth['token'];
		$newauth['state'] = 'loggedin'; 
		return $newauth;
	}

	//check that uid is valid
	if($auth['uid'] && !getUser($auth['uid'])){
		error_log(
			sprintf("unknownState(): uid %d present, but user not in db", 
				$auth['uid'])
		, 0);
		$newauth['uid'] = $auth['uid'];
		$newauth['state'] = 'loggedout'; 
		return $newauth;
	}
	
	// if there's no password stored for this user
	if($auth['uid'] && !getPass($auth['uid'])){
		error_log(
			sprintf("unknownState(): uid %d in db, but null password", 
				$auth['uid']) , 
			0);
		$newauth['uid'] = $auth['uid']; 
		if($auth['pwd']){
			// they attempted to enter a NEW password, so pass it thru.
			$newauth['pwd'] = $auth['pwd']; 
		}
		$newauth['state'] = 'nullpass'; 
		return $newauth;
	}

	// ok, they supplied a password. now... let's check it.
	if($auth['pwd'] && $auth['uid'] ){
		error_log(
			sprintf("unknownState(): uid %d , and pwd provided", 
				$auth['uid']) , 0 );
		$token = checkPass($auth['uid'], $auth['pwd']);
		if($token){
			error_log("unknownState(): password matches!", 0);
			//hooray!! the password is correct! pass it thru
			$newauth['token'] = $token;
			$newauth['state'] = 'loggedin'; 
			return $newauth;
		} else {
			error_log("unknownState(): password does not match", 0);
			//incorrect password. let the pachinko machine handle it
			$newauth['uid'] = $auth['uid'];
			$newauth['state'] = 'wrongpass'; 
			return $newauth;
		}
	} 

	// no pass, no uid, no dice!
	if(!($auth['uid'] && $auth['pwd'])){
		$newauth['state'] = 'loggedout'; 
		return $newauth;
	}

	error_log("unknownState(): unhandled state! an endless loop?", 0);
	return $newauth;
	
}/* END UNKNOWNSTATE */


/******************
	LOGGEDOUTSTATE
	nobody home
******************/
function
loggedOutState($auth)
{
	$newauth = array(
			state => 'unknown'
	);

	if($auth['uid']){
		$uinfo = getUser($auth['uid']);
		$olduser = sprintf("User %s logged out.", $uinfo['username']);
	}
	loginForm($newauth, 'password', 'show', "$olduser Please log in");

	$newauth['state'] = 'needinput'; 
	return $newauth;
	
}/* END LOGGEDOUTSTATE */



/******************
	NULLPASSSTATE
******************/
function
nullPassState($auth)
{
	$newauth = array(
			uid => $auth['uid'],
			state => 'nullpass'
	);

	if(!$auth['pwd']){
		$uinfo = getUser($auth['uid']);
		loginForm($newauth, 'both', 'hide', 
			sprintf("Welcome %s! 
				This must be your first time using the new 
				secure login version of the site. 
				Please choose a new password that you will 
				use for this site from now on, and type it in here.", 
				$uinfo['username']));
		$newauth['state'] = 'needinput'; 
		return $newauth;
	}

	//no confirmation password. need one
	if(!$auth['confirm']){
		$newauth['pwd'] = $auth['pwd'];
		$newauth['state'] = 'needconfirm'; 
		return $newauth;
	}

	// passes don't match
	// TODO: use a hash in pwd, so i'm not passing the pwd around!
	if($auth['pwd'] != $auth['confirm']){
		$newauth['state'] = 'confirmwrong'; 
		return $newauth;
	}

	// insecure, weak password
	if(weakPass($auth['pwd'])){ // NOTE this assumes a cleartext pwd!!
		$newauth['state'] = 'insecurepass'; 
		return $newauth;
	}

	// wow! we made it! a good password! let's save it, shall we?
	$newauth['token'] = savePass($auth['uid'], $auth['pwd']);
	$newauth['state'] = 'loggedin';
	return $newauth;

}/* END NULLPASSSTATE */



/******************
	NEEDCONFIRMSTATE
	loginForm($newauth, 'confirm', 'hide');
******************/
function
needConfirmState($auth)
{
	$newauth = array(
			uid => $auth['uid'],
			pwd => $auth['pwd'], // TODO use a hash in future?
			state => "nullpass" // send me back into nullpass when user returns
	);
	$newauth['state'] = "nullpass";
	loginForm($newauth, 
			$auth['pwd'] ? 'confirm': 'both', 
			'hide', 
			"Please type in the SAME password again, just to make sure.");
	$newauth['state'] = "needinput";
	return $newauth;
}/* END NEEDCONFIRMSTATE */



/******************
	WRONGPASSSTATE
******************/
function
wrongPassState($auth)
{
	// do this before form, to hide data
	$newauth = array(
			uid => $auth['uid'],
			state => "loggedout" // explicitly set it
	);

	loginForm($newauth, 'password', 'hide', 
		"Incorrect password. Please try again." );

	$newauth['state'] = "needinput";
	return $newauth;
}/* END  WRONGPASSSTATE */



/******************
	NOUSERSTATE
******************/
function
noUserState($auth)
{
	$newauth = array(
			state => "loggedout" // explicitly set it
	);
	
	loginForm($newauth, 'password', 'show', "No such user. Try again.");

	$newauth['state'] = "needinput";
	return $newauth;
}/* END NOUSERSTATE */



/******************
	CONFIRMWRONGSTATE
******************/
function
confirmWrongState($auth)
{
	$newauth = array(
			uid => $auth['uid'],
			state => "nullpass" // explicitly set it
	);
	loginForm($newauth, 'both', 'hide',
		"Passwords do not match. Please try again." );

	$newauth['state'] = "needinput";
	return $newauth;
	
}/* END CONFIRMWRONGSTATE */



/******************
	INSECUREPASSSTATE
******************/
function
insecurePassState($auth)
{
	$newauth = array(
			uid => $auth['uid'],
			state => "loggedout" // explicitly set it
	);
	loginForm($newauth, 'both', 'hide',
			"Weak password, please make it at least x letters. 
						Please try again.");

	$newauth['state'] = "needinput";
}/* END INSECUREPASSSTATE */




/******************
	LOGGEDINSTATE
******************/
function
loggedInState($auth)
{
	$newauth = array(
			uid => $auth['uid'],
			token => $auth['token'],
			state => "loggedin"
	);
	return $newauth;
}/* END LOGGEDINSTATE */




/******************
	THRUAUTH
	passes the auth structure right through. this is VITAL for forms!
	inputs: auth, name of struct (default 'auth')
	outputs: auth as invisible fields!
******************/
function
thruAuth($auth, $struct = 'auth')
{
	while (list($key, $val) = each($auth)){
		if($val){
			printf("<INPUT TYPE=hidden NAME='%s[%s]' VALUE='%s'>\n",
				$struct, $key, $val
			);
		}
	}
}/* END THRUAUTH  */



/******************
	WEAKPASS
	inputs: a cleartext password
	returns: 0 if ok, 1 if bad
	TODO code up some regexp's here
******************/
function
weakPass($clearpass)
{
	return 0;
}/* END WEAKPASS */



#note bin2hex... do i need it?

?>
<!-- END AUTH -->
